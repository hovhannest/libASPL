<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libASPL: aspl::Stream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libASPL
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('classaspl_1_1_stream.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classaspl_1_1_stream-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">aspl::Stream Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Audio stream object.  
 <a href="classaspl_1_1_stream.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_stream_8hpp_source.html">aspl/Stream.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for aspl::Stream:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classaspl_1_1_stream.png" usemap="#aspl::Stream_map" alt=""/>
  <map id="aspl::Stream_map" name="aspl::Stream_map">
<area href="classaspl_1_1_object.html" title="Base class for audio objects." alt="aspl::Object" shape="rect" coords="0,56,237,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5bc575a321abcd52cd6e69288dd3cb1b" id="r_a5bc575a321abcd52cd6e69288dd3cb1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a5bc575a321abcd52cd6e69288dd3cb1b">Stream</a> (std::shared_ptr&lt; <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="structaspl_1_1_context.html">Context</a> &gt; <a class="el" href="classaspl_1_1_double_buffer.html">context</a>, std::shared_ptr&lt; <a class="el" href="classaspl_1_1_device.html">Device</a> &gt; <a class="el" href="classaspl_1_1_double_buffer.html">device</a>, <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="structaspl_1_1_stream_parameters.html">StreamParameters</a> &amp;<a class="el" href="classaspl_1_1_double_buffer.html">params</a>={})</td></tr>
<tr class="memdesc:a5bc575a321abcd52cd6e69288dd3cb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct stream.  <br /></td></tr>
<tr class="separator:a5bc575a321abcd52cd6e69288dd3cb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Getters and setters</div></td></tr>
<tr class="memitem:a68583fec1b3439dc38b03c0621adf813" id="r_a68583fec1b3439dc38b03c0621adf813"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a68583fec1b3439dc38b03c0621adf813">GetIsActive</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a68583fec1b3439dc38b03c0621adf813"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tell whether the stream participates in I/O. By default returns the last value set by <a class="el" href="classaspl_1_1_stream.html#a80604ab4a7e215058d396b036f764653" title="Activate or deactivate stream. Invokes SetIsActiveImpl() and NotifyPropertyChanged().">SetIsActive()</a>. Initial value is true.  <br /></td></tr>
<tr class="separator:a68583fec1b3439dc38b03c0621adf813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80604ab4a7e215058d396b036f764653" id="r_a80604ab4a7e215058d396b036f764653"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a80604ab4a7e215058d396b036f764653">SetIsActive</a> (<a class="el" href="classaspl_1_1_double_buffer.html">bool</a> <a class="el" href="classaspl_1_1_double_buffer.html">isActive</a>)</td></tr>
<tr class="memdesc:a80604ab4a7e215058d396b036f764653"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate or deactivate stream. Invokes <a class="el" href="classaspl_1_1_stream.html#a216cad2cde7c521f16429c7caf26421e" title="Activate or deactivate stream. Should return zero if the state was successfully changed....">SetIsActiveImpl()</a> and <a class="el" href="classaspl_1_1_object.html#a53f2d1bb9cd6d4d67e7d5a12208f7e23" title="Notify HAL that a property was changed. This is automatically called by all setters.">NotifyPropertyChanged()</a>.  <br /></td></tr>
<tr class="separator:a80604ab4a7e215058d396b036f764653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363723f08361769c3c1abd4b4bd57cc4" id="r_a363723f08361769c3c1abd4b4bd57cc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="_direction_8hpp.html#a0e5c4fb0e7a72320da52f055c1c91a41">Direction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a363723f08361769c3c1abd4b4bd57cc4">GetDirection</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a363723f08361769c3c1abd4b4bd57cc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stream direction. By default returns corresponding field of <a class="el" href="structaspl_1_1_stream_parameters.html" title="Audio stream parameters.">StreamParameters</a>.  <br /></td></tr>
<tr class="separator:a363723f08361769c3c1abd4b4bd57cc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad832d9656718cf294718f78865e2cc26" id="r_ad832d9656718cf294718f78865e2cc26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#ad832d9656718cf294718f78865e2cc26">GetTerminalType</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:ad832d9656718cf294718f78865e2cc26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get terminal type. By default returns kAudioStreamTerminalTypeMicrophone if <a class="el" href="classaspl_1_1_stream.html#a363723f08361769c3c1abd4b4bd57cc4" title="Get stream direction. By default returns corresponding field of StreamParameters.">GetDirection()</a> returns <a class="el" href="_direction_8hpp.html#a0e5c4fb0e7a72320da52f055c1c91a41a324118a6721dd6b8a9b9f4e327df2bf5" title="Input direction.">Direction::Input</a>, and kAudioStreamTerminalTypeSpeaker if it return <a class="el" href="_direction_8hpp.html#a0e5c4fb0e7a72320da52f055c1c91a41a29c2c02a361c9d7028472e5d92cd4a54" title="Output direction.">Direction::Output</a>.  <br /></td></tr>
<tr class="separator:ad832d9656718cf294718f78865e2cc26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269d731977c0761592a40f83818a951c" id="r_a269d731977c0761592a40f83818a951c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a269d731977c0761592a40f83818a951c">GetStartingChannel</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a269d731977c0761592a40f83818a951c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Absolute channel number for the first channel in the stream. For exmaple, if a device has two output streams with two channels each, then the starting channel number for the first stream is 1 and thus starting channel number for the second stream is 3. By default returns <a class="el" href="structaspl_1_1_stream_parameters.html#a69a2537e7e808c88cda8ae97ab42096a" title="Absolute channel number for the first channel in the stream. Used by default implementation of Stream...">StreamParameters::StartingChannel</a>.  <br /></td></tr>
<tr class="separator:a269d731977c0761592a40f83818a951c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195b7ca824c7f863931411ec13ab5be0" id="r_a195b7ca824c7f863931411ec13ab5be0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a195b7ca824c7f863931411ec13ab5be0">GetChannelCount</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a195b7ca824c7f863931411ec13ab5be0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of channels in stream. Return value is based on <a class="el" href="classaspl_1_1_stream.html#a3779d2d4318459c2fd5ff394ca370d18" title="Get the current physical format of the stream. Physical format defines the underlying format supporte...">GetPhysicalFormat()</a>.  <br /></td></tr>
<tr class="separator:a195b7ca824c7f863931411ec13ab5be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7d1bdf278120bbf0114545f9511c844" id="r_ad7d1bdf278120bbf0114545f9511c844"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">Float64</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#ad7d1bdf278120bbf0114545f9511c844">GetSampleRate</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:ad7d1bdf278120bbf0114545f9511c844"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get stream sample rate. Return value is based on <a class="el" href="classaspl_1_1_stream.html#a3779d2d4318459c2fd5ff394ca370d18" title="Get the current physical format of the stream. Physical format defines the underlying format supporte...">GetPhysicalFormat()</a>.  <br /></td></tr>
<tr class="separator:ad7d1bdf278120bbf0114545f9511c844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af59c95b1f8c4681c1351329e0ac89087" id="r_af59c95b1f8c4681c1351329e0ac89087"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#af59c95b1f8c4681c1351329e0ac89087">GetLatency</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:af59c95b1f8c4681c1351329e0ac89087"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get any additonal presentation latency the stream has. This latency is added to the device latency. By default returns value last set with <a class="el" href="classaspl_1_1_stream.html#a00016a0252cac9276ef829379bc73156" title="Asynchronously set stream presentation latency, Requests HAL to asynchronously invoke SetLatencyImpl(...">SetLatencyAsync()</a>. Initial value is <a class="el" href="structaspl_1_1_stream_parameters.html#abe3b514ef7e948df9e6d8c834f10ed63" title="Additonal presentation latency the stream has. Used by default implementation of Stream::GetLatency()...">StreamParameters::Latency</a>.  <br /></td></tr>
<tr class="separator:af59c95b1f8c4681c1351329e0ac89087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00016a0252cac9276ef829379bc73156" id="r_a00016a0252cac9276ef829379bc73156"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a00016a0252cac9276ef829379bc73156">SetLatencyAsync</a> (<a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> <a class="el" href="classaspl_1_1_double_buffer.html">latency</a>)</td></tr>
<tr class="memdesc:a00016a0252cac9276ef829379bc73156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously set stream presentation latency, Requests HAL to asynchronously invoke <a class="el" href="classaspl_1_1_stream.html#a3b449340ad949b2753a3c47a0d9fa4b4" title="Set stream presentation latency. Invoked by SetLatencyAsync() to actually change the latency....">SetLatencyImpl()</a>.  <br /></td></tr>
<tr class="separator:a00016a0252cac9276ef829379bc73156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3779d2d4318459c2fd5ff394ca370d18" id="r_a3779d2d4318459c2fd5ff394ca370d18"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamBasicDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a3779d2d4318459c2fd5ff394ca370d18">GetPhysicalFormat</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a3779d2d4318459c2fd5ff394ca370d18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current physical format of the stream. Physical format defines the underlying format supported natively by hardware. By default returns value set by last <a class="el" href="classaspl_1_1_stream.html#a94d67ba38b809bce98c61fe750a8af04" title="Set current format of the stream. Requests HAL to asynchronously invoke SetPhysicalFormatImpl()....">SetPhysicalFormatAsync()</a> call. Initial value is <a class="el" href="structaspl_1_1_stream_parameters.html#a97453d492dea4f655d04b609c1ca9be0" title="Stream format. Used by default implementation of Stream::GetPhysicalFormat(). Default format is:">StreamParameters::Format</a>.  <br /></td></tr>
<tr class="separator:a3779d2d4318459c2fd5ff394ca370d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d67ba38b809bce98c61fe750a8af04" id="r_a94d67ba38b809bce98c61fe750a8af04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a94d67ba38b809bce98c61fe750a8af04">SetPhysicalFormatAsync</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamBasicDescription</a> <a class="el" href="classaspl_1_1_double_buffer.html">format</a>)</td></tr>
<tr class="memdesc:a94d67ba38b809bce98c61fe750a8af04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current format of the stream. Requests HAL to asynchronously invoke <a class="el" href="classaspl_1_1_stream.html#a1fbb344a968da9cca8031586ef4c8423" title="Set current format of the stream. Invoked by SetPhysicalFormatAsync() to actually change the format....">SetPhysicalFormatImpl()</a>. Fails if format is not present in <a class="el" href="classaspl_1_1_stream.html#a12ca56e9d287fbe9dbc8ea3ed476acfb" title="Get list of supported physical formats. Empty list means that any format is allowed....">GetAvailablePhysicalFormats()</a>, which by default returns only one format, provided during initialization. If you want to make your stream supporting multiple formats, you typically need to override both of these methods.  <br /></td></tr>
<tr class="separator:a94d67ba38b809bce98c61fe750a8af04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12ca56e9d287fbe9dbc8ea3ed476acfb" id="r_a12ca56e9d287fbe9dbc8ea3ed476acfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamRangedDescription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a12ca56e9d287fbe9dbc8ea3ed476acfb">GetAvailablePhysicalFormats</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a12ca56e9d287fbe9dbc8ea3ed476acfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of supported physical formats. Empty list means that any format is allowed. By default returns the last value set by <a class="el" href="classaspl_1_1_stream.html#a6ce2c0530917cef98c40824cb696cf0d" title="Asynchronously set list of supported physical formats. See comments for GetAvailablePhysicalFormats()...">SetAvailablePhysicalFormatsAsync()</a>. If nothing was set, return a single-element list with the format returned by <a class="el" href="classaspl_1_1_stream.html#a3779d2d4318459c2fd5ff394ca370d18" title="Get the current physical format of the stream. Physical format defines the underlying format supporte...">GetPhysicalFormat()</a>.  <br /></td></tr>
<tr class="separator:a12ca56e9d287fbe9dbc8ea3ed476acfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce2c0530917cef98c40824cb696cf0d" id="r_a6ce2c0530917cef98c40824cb696cf0d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a6ce2c0530917cef98c40824cb696cf0d">SetAvailablePhysicalFormatsAsync</a> (std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamRangedDescription</a> &gt; <a class="el" href="classaspl_1_1_double_buffer.html">formats</a>)</td></tr>
<tr class="memdesc:a6ce2c0530917cef98c40824cb696cf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously set list of supported physical formats. See comments for <a class="el" href="classaspl_1_1_stream.html#a12ca56e9d287fbe9dbc8ea3ed476acfb" title="Get list of supported physical formats. Empty list means that any format is allowed....">GetAvailablePhysicalFormats()</a>. Requests HAL to asynchronously invoke <a class="el" href="classaspl_1_1_stream.html#a945fa39c9b9e6e5f8418f9283f53dcb2" title="Set list of supported physical formats. Invoked by SetAvailablePhysicalFormatsAsync()....">SetAvailablePhysicalFormatsImpl()</a>.  <br /></td></tr>
<tr class="separator:a6ce2c0530917cef98c40824cb696cf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9306afe1da0566a0ecda0882c25f102d" id="r_a9306afe1da0566a0ecda0882c25f102d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamBasicDescription</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a9306afe1da0566a0ecda0882c25f102d">GetVirtualFormat</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a9306afe1da0566a0ecda0882c25f102d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current format of the stream. Virtual format defines the format used to present the device to the apps. For example, physical format may use integers, while virtual format may use floating point numbers. For devices that don't override the mix operation, the virtual format has to be the same as the physical format. By default returns value set by last <a class="el" href="classaspl_1_1_stream.html#aa407cbaf8ebc7fec652b09153616b795" title="Set current virtual format of the stream. Requests HAL to asynchronously invoke SetVirtualFormatImpl(...">SetVirtualFormatAsync()</a> call. Initial value is <a class="el" href="structaspl_1_1_stream_parameters.html#a97453d492dea4f655d04b609c1ca9be0" title="Stream format. Used by default implementation of Stream::GetPhysicalFormat(). Default format is:">StreamParameters::Format</a>.  <br /></td></tr>
<tr class="separator:a9306afe1da0566a0ecda0882c25f102d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa407cbaf8ebc7fec652b09153616b795" id="r_aa407cbaf8ebc7fec652b09153616b795"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#aa407cbaf8ebc7fec652b09153616b795">SetVirtualFormatAsync</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamBasicDescription</a> <a class="el" href="classaspl_1_1_double_buffer.html">format</a>)</td></tr>
<tr class="memdesc:aa407cbaf8ebc7fec652b09153616b795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current virtual format of the stream. Requests HAL to asynchronously invoke <a class="el" href="classaspl_1_1_stream.html#af874a8b508b980c9d6d9e044507eb17d" title="Set current virtual format of the stream. Invoked by SetVirtualFormatAsync() to actually change the f...">SetVirtualFormatImpl()</a>. Fails if format is not present in <a class="el" href="classaspl_1_1_stream.html#a088f0e461c9b7ec3cc7adbe94bd8a68f" title="Get list of supported virtual formats. Empty list means that any format is allowed....">GetAvailableVirtualFormats()</a>, which by default returns only one format, provided during initialization. If you want to make your stream supporting multiple formats, you typically need to override both of these methods.  <br /></td></tr>
<tr class="separator:aa407cbaf8ebc7fec652b09153616b795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088f0e461c9b7ec3cc7adbe94bd8a68f" id="r_a088f0e461c9b7ec3cc7adbe94bd8a68f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamRangedDescription</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a088f0e461c9b7ec3cc7adbe94bd8a68f">GetAvailableVirtualFormats</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a088f0e461c9b7ec3cc7adbe94bd8a68f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get list of supported virtual formats. Empty list means that any format is allowed. By default returns the last value set by <a class="el" href="classaspl_1_1_stream.html#ad0f8920f04795143ef51fc542847116b" title="Asynchronously set list of supported virtual formats. See comments for GetAvailableVirtualFormats()....">SetAvailableVirtualFormatsAsync()</a>. If nothing was set, return a single-element list with the format returned by <a class="el" href="classaspl_1_1_stream.html#a9306afe1da0566a0ecda0882c25f102d" title="Get the current format of the stream. Virtual format defines the format used to present the device to...">GetVirtualFormat()</a>.  <br /></td></tr>
<tr class="separator:a088f0e461c9b7ec3cc7adbe94bd8a68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f8920f04795143ef51fc542847116b" id="r_ad0f8920f04795143ef51fc542847116b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#ad0f8920f04795143ef51fc542847116b">SetAvailableVirtualFormatsAsync</a> (std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamRangedDescription</a> &gt; <a class="el" href="classaspl_1_1_double_buffer.html">formats</a>)</td></tr>
<tr class="memdesc:ad0f8920f04795143ef51fc542847116b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Asynchronously set list of supported virtual formats. See comments for <a class="el" href="classaspl_1_1_stream.html#a088f0e461c9b7ec3cc7adbe94bd8a68f" title="Get list of supported virtual formats. Empty list means that any format is allowed....">GetAvailableVirtualFormats()</a>. Requests HAL to asynchronously invoke <a class="el" href="classaspl_1_1_stream.html#af5526abdc03ab8f87ae812db3cd853e9" title="Set list of supported virtual formats. Invoked by SetAvailableVirtualFormatsAsync()....">SetAvailableVirtualFormatsImpl()</a>.  <br /></td></tr>
<tr class="separator:ad0f8920f04795143ef51fc542847116b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Processing</div></td></tr>
<tr class="memitem:aa7ab1436b25290358ca61aff4c708d63" id="r_aa7ab1436b25290358ca61aff4c708d63"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#aa7ab1436b25290358ca61aff4c708d63">ConvertFramesToBytes</a> (<a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> <a class="el" href="classaspl_1_1_double_buffer.html">numFrames</a>) <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:aa7ab1436b25290358ca61aff4c708d63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert number of frame to the number of bytes. Result depends on the value returned by <a class="el" href="classaspl_1_1_stream.html#a3779d2d4318459c2fd5ff394ca370d18" title="Get the current physical format of the stream. Physical format defines the underlying format supporte...">GetPhysicalFormat()</a>.  <br /></td></tr>
<tr class="separator:aa7ab1436b25290358ca61aff4c708d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a111814d680ca3cf5762a794a6102a5b7" id="r_a111814d680ca3cf5762a794a6102a5b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a111814d680ca3cf5762a794a6102a5b7">ConvertBytesToFrames</a> (<a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> <a class="el" href="classaspl_1_1_double_buffer.html">numBytes</a>) <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a111814d680ca3cf5762a794a6102a5b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert number of bytes to the number of frames. Result depends on the value returned by <a class="el" href="classaspl_1_1_stream.html#a3779d2d4318459c2fd5ff394ca370d18" title="Get the current physical format of the stream. Physical format defines the underlying format supporte...">GetPhysicalFormat()</a>.  <br /></td></tr>
<tr class="separator:a111814d680ca3cf5762a794a6102a5b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ac54804f85b7a183de4b92960c73e3" id="r_a15ac54804f85b7a183de4b92960c73e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a15ac54804f85b7a183de4b92960c73e3">AttachVolumeControl</a> (std::shared_ptr&lt; <a class="el" href="classaspl_1_1_volume_control.html">VolumeControl</a> &gt; <a class="el" href="classaspl_1_1_double_buffer.html">control</a>)</td></tr>
<tr class="memdesc:a15ac54804f85b7a183de4b92960c73e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach volume control to the stream. <a class="el" href="classaspl_1_1_stream.html#a28cbc9be59540d32a56913e72f9569cd" title="Apply processing to the stream&#39;s data. The provided buffer contains exactly frameCount * channelCount...">ApplyProcessing()</a> will use control to apply volume settings to the stream.  <br /></td></tr>
<tr class="separator:a15ac54804f85b7a183de4b92960c73e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7db6576eb4ceabc4b248b6638ce2d3" id="r_aae7db6576eb4ceabc4b248b6638ce2d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#aae7db6576eb4ceabc4b248b6638ce2d3">AttachMuteControl</a> (std::shared_ptr&lt; <a class="el" href="classaspl_1_1_mute_control.html">MuteControl</a> &gt; <a class="el" href="classaspl_1_1_double_buffer.html">control</a>)</td></tr>
<tr class="memdesc:aae7db6576eb4ceabc4b248b6638ce2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach mute control to the stream. <a class="el" href="classaspl_1_1_stream.html#a28cbc9be59540d32a56913e72f9569cd" title="Apply processing to the stream&#39;s data. The provided buffer contains exactly frameCount * channelCount...">ApplyProcessing()</a> will use control to apply mute settings to the stream.  <br /></td></tr>
<tr class="separator:aae7db6576eb4ceabc4b248b6638ce2d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28cbc9be59540d32a56913e72f9569cd" id="r_a28cbc9be59540d32a56913e72f9569cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a28cbc9be59540d32a56913e72f9569cd">ApplyProcessing</a> (<a class="el" href="classaspl_1_1_double_buffer.html">Float32</a> *<a class="el" href="classaspl_1_1_double_buffer.html">frames</a>, <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> <a class="el" href="classaspl_1_1_double_buffer.html">frameCount</a>, <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> <a class="el" href="classaspl_1_1_double_buffer.html">channelCount</a>) <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a28cbc9be59540d32a56913e72f9569cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply processing to the stream's data. The provided buffer contains exactly <code>frameCount</code> * <code>channelCount</code> samples. Modifies frames in the provided buffer. Default implementation invokes <a class="el" href="classaspl_1_1_stream.html#a28cbc9be59540d32a56913e72f9569cd" title="Apply processing to the stream&#39;s data. The provided buffer contains exactly frameCount * channelCount...">ApplyProcessing()</a> on attached volume and mute controls, if they are present.  <br /></td></tr>
<tr class="separator:a28cbc9be59540d32a56913e72f9569cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Configuration</div></td></tr>
<tr class="memitem:af7ffc3cb8d8e121db0ca98c2c60b621b" id="r_af7ffc3cb8d8e121db0ca98c2c60b621b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#af7ffc3cb8d8e121db0ca98c2c60b621b">RequestConfigurationChange</a> (std::function&lt; <a class="el" href="classaspl_1_1_double_buffer.html">void</a>()&gt; <a class="el" href="classaspl_1_1_double_buffer.html">func</a>={})</td></tr>
<tr class="memdesc:af7ffc3cb8d8e121db0ca98c2c60b621b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Request HAL to perform configuration update. Similar to <a class="el" href="classaspl_1_1_device.html#a9a5aeeacc257fbc5974de7d7c7177589" title="Request HAL to perform configuration update.">Device::RequestConfigurationChange()</a>.  <br /></td></tr>
<tr class="separator:af7ffc3cb8d8e121db0ca98c2c60b621b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Property dispath</div></td></tr>
<tr class="memitem:ab0247f7359d6632552ad98f841a050b8" id="r_ab0247f7359d6632552ad98f841a050b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">AudioClassID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#ab0247f7359d6632552ad98f841a050b8">GetClass</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">override</a></td></tr>
<tr class="memdesc:ab0247f7359d6632552ad98f841a050b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get class ID.  <br /></td></tr>
<tr class="separator:ab0247f7359d6632552ad98f841a050b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9246a40921eceb1469aaa2cadbedc9" id="r_ada9246a40921eceb1469aaa2cadbedc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">AudioClassID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#ada9246a40921eceb1469aaa2cadbedc9">GetBaseClass</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">override</a></td></tr>
<tr class="memdesc:ada9246a40921eceb1469aaa2cadbedc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get base class ID.  <br /></td></tr>
<tr class="separator:ada9246a40921eceb1469aaa2cadbedc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4da7a1929c7b397754c05b673e85769" id="r_ad4da7a1929c7b397754c05b673e85769"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#ad4da7a1929c7b397754c05b673e85769">IsInstance</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioClassID</a> <a class="el" href="classaspl_1_1_double_buffer.html">classID</a>) <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">override</a></td></tr>
<tr class="memdesc:ad4da7a1929c7b397754c05b673e85769"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if this object is instance of given base class.  <br /></td></tr>
<tr class="separator:ad4da7a1929c7b397754c05b673e85769"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9af7fb00e85380539243bb11ba73be" id="r_a7d9af7fb00e85380539243bb11ba73be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">Boolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a7d9af7fb00e85380539243bb11ba73be">HasProperty</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a> <a class="el" href="classaspl_1_1_double_buffer.html">objectID</a>, <a class="el" href="classaspl_1_1_double_buffer.html">pid_t</a> <a class="el" href="classaspl_1_1_double_buffer.html">clientPID</a>, <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyAddress</a> *<a class="el" href="classaspl_1_1_double_buffer.html">address</a>) <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">override</a></td></tr>
<tr class="memdesc:a7d9af7fb00e85380539243bb11ba73be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether given property is present.  <br /></td></tr>
<tr class="separator:a7d9af7fb00e85380539243bb11ba73be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cef45207c5c0b071644c8274d66ff39" id="r_a0cef45207c5c0b071644c8274d66ff39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a0cef45207c5c0b071644c8274d66ff39">IsPropertySettable</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a> <a class="el" href="classaspl_1_1_double_buffer.html">objectID</a>, <a class="el" href="classaspl_1_1_double_buffer.html">pid_t</a> <a class="el" href="classaspl_1_1_double_buffer.html">clientPID</a>, <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyAddress</a> *<a class="el" href="classaspl_1_1_double_buffer.html">address</a>, <a class="el" href="classaspl_1_1_double_buffer.html">Boolean</a> *<a class="el" href="classaspl_1_1_double_buffer.html">outIsSettable</a>) <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">override</a></td></tr>
<tr class="memdesc:a0cef45207c5c0b071644c8274d66ff39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether given property can be changed.  <br /></td></tr>
<tr class="separator:a0cef45207c5c0b071644c8274d66ff39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c3831ad6c98a7b5c8f81a137523e82" id="r_ac3c3831ad6c98a7b5c8f81a137523e82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#ac3c3831ad6c98a7b5c8f81a137523e82">GetPropertyDataSize</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a> <a class="el" href="classaspl_1_1_double_buffer.html">objectID</a>, <a class="el" href="classaspl_1_1_double_buffer.html">pid_t</a> <a class="el" href="classaspl_1_1_double_buffer.html">clientPID</a>, <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyAddress</a> *<a class="el" href="classaspl_1_1_double_buffer.html">address</a>, <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> <a class="el" href="classaspl_1_1_double_buffer.html">qualifierDataSize</a>, <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">void</a> *<a class="el" href="classaspl_1_1_double_buffer.html">qualifierData</a>, <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> *<a class="el" href="classaspl_1_1_double_buffer.html">outDataSize</a>) <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">override</a></td></tr>
<tr class="memdesc:ac3c3831ad6c98a7b5c8f81a137523e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get size of property value in bytes.  <br /></td></tr>
<tr class="separator:ac3c3831ad6c98a7b5c8f81a137523e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a51d941176990e0a4de3188dda6b826" id="r_a8a51d941176990e0a4de3188dda6b826"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a8a51d941176990e0a4de3188dda6b826">GetPropertyData</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a> <a class="el" href="classaspl_1_1_double_buffer.html">objectID</a>, <a class="el" href="classaspl_1_1_double_buffer.html">pid_t</a> <a class="el" href="classaspl_1_1_double_buffer.html">clientPID</a>, <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyAddress</a> *<a class="el" href="classaspl_1_1_double_buffer.html">address</a>, <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> <a class="el" href="classaspl_1_1_double_buffer.html">qualifierDataSize</a>, <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">void</a> *<a class="el" href="classaspl_1_1_double_buffer.html">qualifierData</a>, <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> <a class="el" href="classaspl_1_1_double_buffer.html">inDataSize</a>, <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> *<a class="el" href="classaspl_1_1_double_buffer.html">outDataSize</a>, <a class="el" href="classaspl_1_1_double_buffer.html">void</a> *<a class="el" href="classaspl_1_1_double_buffer.html">outData</a>) <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">override</a></td></tr>
<tr class="memdesc:a8a51d941176990e0a4de3188dda6b826"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get property value.  <br /></td></tr>
<tr class="separator:a8a51d941176990e0a4de3188dda6b826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5640cd0c7dcc99c9a2956527591f4d2b" id="r_a5640cd0c7dcc99c9a2956527591f4d2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a5640cd0c7dcc99c9a2956527591f4d2b">SetPropertyData</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a> <a class="el" href="classaspl_1_1_double_buffer.html">objectID</a>, <a class="el" href="classaspl_1_1_double_buffer.html">pid_t</a> <a class="el" href="classaspl_1_1_double_buffer.html">clientPID</a>, <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyAddress</a> *<a class="el" href="classaspl_1_1_double_buffer.html">address</a>, <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> <a class="el" href="classaspl_1_1_double_buffer.html">qualifierDataSize</a>, <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">void</a> *<a class="el" href="classaspl_1_1_double_buffer.html">qualifierData</a>, <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> <a class="el" href="classaspl_1_1_double_buffer.html">inDataSize</a>, <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">void</a> *<a class="el" href="classaspl_1_1_double_buffer.html">inData</a>) <a class="el" href="classaspl_1_1_double_buffer.html">override</a></td></tr>
<tr class="memdesc:a5640cd0c7dcc99c9a2956527591f4d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change property value.  <br /></td></tr>
<tr class="separator:a5640cd0c7dcc99c9a2956527591f4d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classaspl_1_1_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classaspl_1_1_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classaspl_1_1_object.html">aspl::Object</a></td></tr>
<tr class="memitem:adabd65c52660545c16bf7b08e0725526 inherit pub_methods_classaspl_1_1_object" id="r_adabd65c52660545c16bf7b08e0725526"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#adabd65c52660545c16bf7b08e0725526">Object</a> (std::shared_ptr&lt; <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="structaspl_1_1_context.html">Context</a> &gt; <a class="el" href="classaspl_1_1_double_buffer.html">context</a>, <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">char</a> *<a class="el" href="classaspl_1_1_double_buffer.html">className</a>=&quot;Object&quot;, <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a> <a class="el" href="classaspl_1_1_double_buffer.html">objectID</a>=<a class="el" href="classaspl_1_1_double_buffer.html">kAudioObjectUnknown</a>)</td></tr>
<tr class="memdesc:adabd65c52660545c16bf7b08e0725526 inherit pub_methods_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct object. Class name is used for logging. It should be the name of the derived class. If objectID is <code>kAudioObjectUnknown</code> (zero), allocates new object ID. Otherwise uses given object ID.  <br /></td></tr>
<tr class="separator:adabd65c52660545c16bf7b08e0725526 inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a687624b03b413ce4b004ba84e2b73b59 inherit pub_methods_classaspl_1_1_object" id="r_a687624b03b413ce4b004ba84e2b73b59"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>Object</b> (<a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_object.html">Object</a> &amp;)=<a class="el" href="classaspl_1_1_double_buffer.html">delete</a></td></tr>
<tr class="separator:a687624b03b413ce4b004ba84e2b73b59 inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a2df0b8fbcdb32ac155750a6f9dc392 inherit pub_methods_classaspl_1_1_object" id="r_a4a2df0b8fbcdb32ac155750a6f9dc392"><td class="memItemLeft" align="right" valign="top">
<a class="el" href="classaspl_1_1_object.html">Object</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_object.html">Object</a> &amp;)=<a class="el" href="classaspl_1_1_double_buffer.html">delete</a></td></tr>
<tr class="separator:a4a2df0b8fbcdb32ac155750a6f9dc392 inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55c052b15a636453ad42ed2f1104e31 inherit pub_methods_classaspl_1_1_object" id="r_ab55c052b15a636453ad42ed2f1104e31"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="structaspl_1_1_context.html">Context</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#ab55c052b15a636453ad42ed2f1104e31">GetContext</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:ab55c052b15a636453ad42ed2f1104e31 inherit pub_methods_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get object context.  <br /></td></tr>
<tr class="separator:ab55c052b15a636453ad42ed2f1104e31 inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b19f0ee031d9c69247b97d21a413b79 inherit pub_methods_classaspl_1_1_object" id="r_a8b19f0ee031d9c69247b97d21a413b79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#a8b19f0ee031d9c69247b97d21a413b79">GetID</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a8b19f0ee031d9c69247b97d21a413b79 inherit pub_methods_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get object ID. Returns objectID selected at construction time.  <br /></td></tr>
<tr class="separator:a8b19f0ee031d9c69247b97d21a413b79 inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39507e64e1d6ac5dc2493e18a2a8b1c2 inherit pub_methods_classaspl_1_1_object" id="r_a39507e64e1d6ac5dc2493e18a2a8b1c2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#a39507e64e1d6ac5dc2493e18a2a8b1c2">GetOwnerID</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a39507e64e1d6ac5dc2493e18a2a8b1c2 inherit pub_methods_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get object owner. If the object has an owner, returns its ID. Otherwise, returns <code>kAudioObjectUnknown</code> (zero).  <br /></td></tr>
<tr class="separator:a39507e64e1d6ac5dc2493e18a2a8b1c2 inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4a7c691cd7cbe5c7768f9c35608c93 inherit pub_methods_classaspl_1_1_object" id="r_a4d4a7c691cd7cbe5c7768f9c35608c93"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#a4d4a7c691cd7cbe5c7768f9c35608c93">GetOwnedObjectIDs</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyScope</a> <a class="el" href="classaspl_1_1_double_buffer.html">scope</a>=<a class="el" href="classaspl_1_1_double_buffer.html">kAudioObjectPropertyScopeGlobal</a>, <a class="el" href="classaspl_1_1_double_buffer.html">AudioClassID</a> <a class="el" href="classaspl_1_1_double_buffer.html">classID</a>=0) <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a4d4a7c691cd7cbe5c7768f9c35608c93 inherit pub_methods_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get owned objects. Returns the list of objects to which this object is the owner.  <br /></td></tr>
<tr class="separator:a4d4a7c691cd7cbe5c7768f9c35608c93 inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb51aa4a29b2ea38f7bfdd5947226da2 inherit pub_methods_classaspl_1_1_object" id="r_abb51aa4a29b2ea38f7bfdd5947226da2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#abb51aa4a29b2ea38f7bfdd5947226da2">AddOwnedObject</a> (std::shared_ptr&lt; <a class="el" href="classaspl_1_1_object.html">Object</a> &gt; object, <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyScope</a> <a class="el" href="classaspl_1_1_double_buffer.html">scope</a>=<a class="el" href="classaspl_1_1_double_buffer.html">kAudioObjectPropertyScopeGlobal</a>)</td></tr>
<tr class="memdesc:abb51aa4a29b2ea38f7bfdd5947226da2 inherit pub_methods_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add object to the list of owned objects. Also invokes SetOwner() on the added object.  <br /></td></tr>
<tr class="separator:abb51aa4a29b2ea38f7bfdd5947226da2 inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9ec958389a7fd5d58d23bc248170d4 inherit pub_methods_classaspl_1_1_object" id="r_afa9ec958389a7fd5d58d23bc248170d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#afa9ec958389a7fd5d58d23bc248170d4">RemoveOwnedObject</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a> <a class="el" href="classaspl_1_1_double_buffer.html">objectID</a>)</td></tr>
<tr class="memdesc:afa9ec958389a7fd5d58d23bc248170d4 inherit pub_methods_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove object to the list of owned objects. Also invokes SetOwner() on the removed object.  <br /></td></tr>
<tr class="separator:afa9ec958389a7fd5d58d23bc248170d4 inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53f2d1bb9cd6d4d67e7d5a12208f7e23 inherit pub_methods_classaspl_1_1_object" id="r_a53f2d1bb9cd6d4d67e7d5a12208f7e23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#a53f2d1bb9cd6d4d67e7d5a12208f7e23">NotifyPropertyChanged</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertySelector</a> <a class="el" href="classaspl_1_1_double_buffer.html">selector</a>, <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyScope</a> <a class="el" href="classaspl_1_1_double_buffer.html">scope</a>=<a class="el" href="classaspl_1_1_double_buffer.html">kAudioObjectPropertyScopeGlobal</a>, <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyElement</a> <a class="el" href="classaspl_1_1_double_buffer.html">element</a>=kAudioObjectPropertyElementMain) <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a53f2d1bb9cd6d4d67e7d5a12208f7e23 inherit pub_methods_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify HAL that a property was changed. This is automatically called by all setters.  <br /></td></tr>
<tr class="separator:a53f2d1bb9cd6d4d67e7d5a12208f7e23 inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dae19608b75d90b7c47504e93c07496 inherit pub_methods_classaspl_1_1_object" id="r_a9dae19608b75d90b7c47504e93c07496"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#a9dae19608b75d90b7c47504e93c07496">NotifyPropertiesChanged</a> (std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertySelector</a> &gt; <a class="el" href="classaspl_1_1_double_buffer.html">selectors</a>, <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyScope</a> <a class="el" href="classaspl_1_1_double_buffer.html">scope</a>=<a class="el" href="classaspl_1_1_double_buffer.html">kAudioObjectPropertyScopeGlobal</a>, <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyElement</a> <a class="el" href="classaspl_1_1_double_buffer.html">element</a>=kAudioObjectPropertyElementMain) <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a9dae19608b75d90b7c47504e93c07496 inherit pub_methods_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Notify HAL that some properties were changed. This is automatically called by all setters.  <br /></td></tr>
<tr class="separator:a9dae19608b75d90b7c47504e93c07496 inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa335089b3a53e56de677af9cc17a06b2 inherit pub_methods_classaspl_1_1_object" id="r_aa335089b3a53e56de677af9cc17a06b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioServerPlugInCustomPropertyInfo</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#aa335089b3a53e56de677af9cc17a06b2">GetCustomProperties</a> () <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:aa335089b3a53e56de677af9cc17a06b2 inherit pub_methods_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get info about registered custom properties. Returns list of properties added using <a class="el" href="classaspl_1_1_object.html#a5504b80ece87093ac16daff970a4685b" title="Register custom property with getter and optional setter.">RegisterCustomProperty()</a>.  <br /></td></tr>
<tr class="separator:aa335089b3a53e56de677af9cc17a06b2 inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5504b80ece87093ac16daff970a4685b inherit pub_methods_classaspl_1_1_object" id="r_a5504b80ece87093ac16daff970a4685b"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classaspl_1_1_double_buffer.html">typename</a> <a class="el" href="classaspl_1_1_double_buffer.html">ObjectType</a> , <a class="el" href="classaspl_1_1_double_buffer.html">typename</a> <a class="el" href="classaspl_1_1_double_buffer.html">ValueType</a> &gt; </td></tr>
<tr class="memitem:a5504b80ece87093ac16daff970a4685b inherit pub_methods_classaspl_1_1_object"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#a5504b80ece87093ac16daff970a4685b">RegisterCustomProperty</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertySelector</a> <a class="el" href="classaspl_1_1_double_buffer.html">selector</a>, <a class="el" href="classaspl_1_1_double_buffer.html">ObjectType</a> &amp;object, <a class="el" href="classaspl_1_1_object.html#a3b453b84eaa98e95a3ff320a54e33242">GetterMethod</a>&lt; <a class="el" href="classaspl_1_1_double_buffer.html">ObjectType</a>, <a class="el" href="classaspl_1_1_double_buffer.html">ValueType</a> &gt; <a class="el" href="classaspl_1_1_double_buffer.html">getter</a>, <a class="el" href="classaspl_1_1_object.html#ab65717e9947ddf9455ff9c96d6c87e4f">SetterMethod</a>&lt; <a class="el" href="classaspl_1_1_double_buffer.html">ObjectType</a>, <a class="el" href="classaspl_1_1_double_buffer.html">ValueType</a> &gt; <a class="el" href="classaspl_1_1_double_buffer.html">setter</a>=<a class="el" href="classaspl_1_1_double_buffer.html">nullptr</a>)</td></tr>
<tr class="memdesc:a5504b80ece87093ac16daff970a4685b inherit pub_methods_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register custom property with getter and optional setter.  <br /></td></tr>
<tr class="separator:a5504b80ece87093ac16daff970a4685b inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ab249e4c7641a2517399431a3c6b90 inherit pub_methods_classaspl_1_1_object" id="r_aa9ab249e4c7641a2517399431a3c6b90"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classaspl_1_1_double_buffer.html">typename</a> <a class="el" href="classaspl_1_1_double_buffer.html">GetterFunc</a> &gt; </td></tr>
<tr class="memitem:aa9ab249e4c7641a2517399431a3c6b90 inherit pub_methods_classaspl_1_1_object"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">void</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#aa9ab249e4c7641a2517399431a3c6b90">RegisterCustomProperty</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertySelector</a> <a class="el" href="classaspl_1_1_double_buffer.html">selector</a>, <a class="el" href="classaspl_1_1_double_buffer.html">GetterFunc</a> <a class="el" href="classaspl_1_1_double_buffer.html">getter</a>)</td></tr>
<tr class="memdesc:aa9ab249e4c7641a2517399431a3c6b90 inherit pub_methods_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register custom property with getter and optional setter.  <br /></td></tr>
<tr class="separator:aa9ab249e4c7641a2517399431a3c6b90 inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab9cdea9575976bdead270d2183391cf inherit pub_methods_classaspl_1_1_object" id="r_aab9cdea9575976bdead270d2183391cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#aab9cdea9575976bdead270d2183391cf">RegisterCustomProperty</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertySelector</a> <a class="el" href="classaspl_1_1_double_buffer.html">selector</a>, std::function&lt; <a class="el" href="classaspl_1_1_double_buffer.html">CFStringRef</a>()&gt; <a class="el" href="classaspl_1_1_double_buffer.html">getter</a>, std::function&lt; <a class="el" href="classaspl_1_1_double_buffer.html">void</a>(<a class="el" href="classaspl_1_1_double_buffer.html">CFStringRef</a>)&gt; <a class="el" href="classaspl_1_1_double_buffer.html">setter</a>)</td></tr>
<tr class="memdesc:aab9cdea9575976bdead270d2183391cf inherit pub_methods_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register custom property with getter and optional setter.  <br /></td></tr>
<tr class="separator:aab9cdea9575976bdead270d2183391cf inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b8fa72591095c47279a8a8521c44f4 inherit pub_methods_classaspl_1_1_object" id="r_ae2b8fa72591095c47279a8a8521c44f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">void</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#ae2b8fa72591095c47279a8a8521c44f4">RegisterCustomProperty</a> (<a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertySelector</a> <a class="el" href="classaspl_1_1_double_buffer.html">selector</a>, std::function&lt; <a class="el" href="classaspl_1_1_double_buffer.html">CFPropertyListRef</a>()&gt; <a class="el" href="classaspl_1_1_double_buffer.html">getter</a>, std::function&lt; <a class="el" href="classaspl_1_1_double_buffer.html">void</a>(<a class="el" href="classaspl_1_1_double_buffer.html">CFPropertyListRef</a>)&gt; <a class="el" href="classaspl_1_1_double_buffer.html">setter</a>)</td></tr>
<tr class="memdesc:ae2b8fa72591095c47279a8a8521c44f4 inherit pub_methods_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register custom property with getter and optional setter.  <br /></td></tr>
<tr class="separator:ae2b8fa72591095c47279a8a8521c44f4 inherit pub_methods_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Setters implementation</div></td></tr>
<tr class="memitem:a216cad2cde7c521f16429c7caf26421e" id="r_a216cad2cde7c521f16429c7caf26421e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a216cad2cde7c521f16429c7caf26421e">SetIsActiveImpl</a> (<a class="el" href="classaspl_1_1_double_buffer.html">bool</a> <a class="el" href="classaspl_1_1_double_buffer.html">isActive</a>)</td></tr>
<tr class="memdesc:a216cad2cde7c521f16429c7caf26421e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate or deactivate stream. Should return zero if the state was successfully changed. By default just changes the value returned by <a class="el" href="classaspl_1_1_stream.html#a68583fec1b3439dc38b03c0621adf813" title="Tell whether the stream participates in I/O. By default returns the last value set by SetIsActive()....">GetIsActive()</a>. Invoked by <a class="el" href="classaspl_1_1_stream.html#a80604ab4a7e215058d396b036f764653" title="Activate or deactivate stream. Invokes SetIsActiveImpl() and NotifyPropertyChanged().">SetIsActive()</a>.  <br /></td></tr>
<tr class="separator:a216cad2cde7c521f16429c7caf26421e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b449340ad949b2753a3c47a0d9fa4b4" id="r_a3b449340ad949b2753a3c47a0d9fa4b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a3b449340ad949b2753a3c47a0d9fa4b4">SetLatencyImpl</a> (<a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> <a class="el" href="classaspl_1_1_double_buffer.html">latency</a>)</td></tr>
<tr class="memdesc:a3b449340ad949b2753a3c47a0d9fa4b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set stream presentation latency. Invoked by <a class="el" href="classaspl_1_1_stream.html#a00016a0252cac9276ef829379bc73156" title="Asynchronously set stream presentation latency, Requests HAL to asynchronously invoke SetLatencyImpl(...">SetLatencyAsync()</a> to actually change the latency. Default implementation just changes the value returned by <a class="el" href="classaspl_1_1_stream.html#af59c95b1f8c4681c1351329e0ac89087" title="Get any additonal presentation latency the stream has. This latency is added to the device latency....">GetLatency()</a>.  <br /></td></tr>
<tr class="separator:a3b449340ad949b2753a3c47a0d9fa4b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbb344a968da9cca8031586ef4c8423" id="r_a1fbb344a968da9cca8031586ef4c8423"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a1fbb344a968da9cca8031586ef4c8423">SetPhysicalFormatImpl</a> (<a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamBasicDescription</a> &amp;<a class="el" href="classaspl_1_1_double_buffer.html">format</a>)</td></tr>
<tr class="memdesc:a1fbb344a968da9cca8031586ef4c8423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current format of the stream. Invoked by <a class="el" href="classaspl_1_1_stream.html#a94d67ba38b809bce98c61fe750a8af04" title="Set current format of the stream. Requests HAL to asynchronously invoke SetPhysicalFormatImpl()....">SetPhysicalFormatAsync()</a> to actually change the format. Default behavior is to change the format returned by <a class="el" href="classaspl_1_1_stream.html#a3779d2d4318459c2fd5ff394ca370d18" title="Get the current physical format of the stream. Physical format defines the underlying format supporte...">GetPhysicalFormat()</a> and to invoke Device::SetSampleRateAsync() to ensure that device and all its streams have the same rate.  <br /></td></tr>
<tr class="separator:a1fbb344a968da9cca8031586ef4c8423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945fa39c9b9e6e5f8418f9283f53dcb2" id="r_a945fa39c9b9e6e5f8418f9283f53dcb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#a945fa39c9b9e6e5f8418f9283f53dcb2">SetAvailablePhysicalFormatsImpl</a> (std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamRangedDescription</a> &gt; <a class="el" href="classaspl_1_1_double_buffer.html">formats</a>)</td></tr>
<tr class="memdesc:a945fa39c9b9e6e5f8418f9283f53dcb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set list of supported physical formats. Invoked by <a class="el" href="classaspl_1_1_stream.html#a6ce2c0530917cef98c40824cb696cf0d" title="Asynchronously set list of supported physical formats. See comments for GetAvailablePhysicalFormats()...">SetAvailablePhysicalFormatsAsync()</a>. Default implementation just changes the list returned by <a class="el" href="classaspl_1_1_stream.html#a12ca56e9d287fbe9dbc8ea3ed476acfb" title="Get list of supported physical formats. Empty list means that any format is allowed....">GetAvailablePhysicalFormats()</a>.  <br /></td></tr>
<tr class="separator:a945fa39c9b9e6e5f8418f9283f53dcb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af874a8b508b980c9d6d9e044507eb17d" id="r_af874a8b508b980c9d6d9e044507eb17d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#af874a8b508b980c9d6d9e044507eb17d">SetVirtualFormatImpl</a> (<a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamBasicDescription</a> &amp;<a class="el" href="classaspl_1_1_double_buffer.html">format</a>)</td></tr>
<tr class="memdesc:af874a8b508b980c9d6d9e044507eb17d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current virtual format of the stream. Invoked by <a class="el" href="classaspl_1_1_stream.html#aa407cbaf8ebc7fec652b09153616b795" title="Set current virtual format of the stream. Requests HAL to asynchronously invoke SetVirtualFormatImpl(...">SetVirtualFormatAsync()</a> to actually change the format. Default behavior is to change the format returned by <a class="el" href="classaspl_1_1_stream.html#a9306afe1da0566a0ecda0882c25f102d" title="Get the current format of the stream. Virtual format defines the format used to present the device to...">GetVirtualFormat()</a> and to invoke Device::SetSampleRateAsync() to ensure that device and all its streams have the same rate.  <br /></td></tr>
<tr class="separator:af874a8b508b980c9d6d9e044507eb17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5526abdc03ab8f87ae812db3cd853e9" id="r_af5526abdc03ab8f87ae812db3cd853e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classaspl_1_1_stream.html#af5526abdc03ab8f87ae812db3cd853e9">SetAvailableVirtualFormatsImpl</a> (std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamRangedDescription</a> &gt; <a class="el" href="classaspl_1_1_double_buffer.html">formats</a>)</td></tr>
<tr class="memdesc:af5526abdc03ab8f87ae812db3cd853e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set list of supported virtual formats. Invoked by <a class="el" href="classaspl_1_1_stream.html#ad0f8920f04795143ef51fc542847116b" title="Asynchronously set list of supported virtual formats. See comments for GetAvailableVirtualFormats()....">SetAvailableVirtualFormatsAsync()</a>. Default implementation just changes the list returned by <a class="el" href="classaspl_1_1_stream.html#a088f0e461c9b7ec3cc7adbe94bd8a68f" title="Get list of supported virtual formats. Empty list means that any format is allowed....">GetAvailableVirtualFormats()</a>.  <br /></td></tr>
<tr class="separator:af5526abdc03ab8f87ae812db3cd853e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classaspl_1_1_object"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classaspl_1_1_object')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classaspl_1_1_object.html">aspl::Object</a></td></tr>
<tr class="memitem:a3b453b84eaa98e95a3ff320a54e33242 inherit pub_types_classaspl_1_1_object" id="r_a3b453b84eaa98e95a3ff320a54e33242"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classaspl_1_1_double_buffer.html">typename</a> <a class="el" href="classaspl_1_1_double_buffer.html">ObjectType</a> , <a class="el" href="classaspl_1_1_double_buffer.html">typename</a> <a class="el" href="classaspl_1_1_double_buffer.html">ValueType</a> &gt; </td></tr>
<tr class="memitem:a3b453b84eaa98e95a3ff320a54e33242 inherit pub_types_classaspl_1_1_object"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#a3b453b84eaa98e95a3ff320a54e33242">GetterMethod</a> = <a class="el" href="classaspl_1_1_double_buffer.html">ValueType</a>(ObjectType::*)() <a class="el" href="classaspl_1_1_double_buffer.html">const</a></td></tr>
<tr class="memdesc:a3b453b84eaa98e95a3ff320a54e33242 inherit pub_types_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to custom property getter method. Used in <a class="el" href="classaspl_1_1_object.html#a5504b80ece87093ac16daff970a4685b" title="Register custom property with getter and optional setter.">RegisterCustomProperty()</a>.  <br /></td></tr>
<tr class="separator:a3b453b84eaa98e95a3ff320a54e33242 inherit pub_types_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65717e9947ddf9455ff9c96d6c87e4f inherit pub_types_classaspl_1_1_object" id="r_ab65717e9947ddf9455ff9c96d6c87e4f"><td class="memTemplParams" colspan="2">template&lt;<a class="el" href="classaspl_1_1_double_buffer.html">typename</a> <a class="el" href="classaspl_1_1_double_buffer.html">ObjectType</a> , <a class="el" href="classaspl_1_1_double_buffer.html">typename</a> <a class="el" href="classaspl_1_1_double_buffer.html">ValueType</a> &gt; </td></tr>
<tr class="memitem:ab65717e9947ddf9455ff9c96d6c87e4f inherit pub_types_classaspl_1_1_object"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classaspl_1_1_double_buffer.html">using</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classaspl_1_1_object.html#ab65717e9947ddf9455ff9c96d6c87e4f">SetterMethod</a> = <a class="el" href="classaspl_1_1_double_buffer.html">void</a>(ObjectType::*)(<a class="el" href="classaspl_1_1_double_buffer.html">ValueType</a>)</td></tr>
<tr class="memdesc:ab65717e9947ddf9455ff9c96d6c87e4f inherit pub_types_classaspl_1_1_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to custom property setter method. Used in <a class="el" href="classaspl_1_1_object.html#a5504b80ece87093ac16daff970a4685b" title="Register custom property with getter and optional setter.">RegisterCustomProperty()</a>.  <br /></td></tr>
<tr class="separator:ab65717e9947ddf9455ff9c96d6c87e4f inherit pub_types_classaspl_1_1_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Audio stream object. </p>
<p><a class="el" href="classaspl_1_1_stream.html" title="Audio stream object.">Stream</a> is part of a <a class="el" href="classaspl_1_1_device.html" title="Audio device object.">Device</a> representing a source (input stream) or a destination (output stream) for samples. Clients connected to the device can read from its input streams and write to its output streams.</p>
<p>Each stream can have its own format, latency, and other parameters.</p>
<p><a class="el" href="classaspl_1_1_stream.html" title="Audio stream object.">Stream</a> does not do I/O by its own. Instead, it provides <a class="el" href="classaspl_1_1_stream.html#a28cbc9be59540d32a56913e72f9569cd" title="Apply processing to the stream&#39;s data. The provided buffer contains exactly frameCount * channelCount...">ApplyProcessing()</a> method, which is invoked by ReaderWriter (in its default implementation).</p>
<p>Default implementation of <a class="el" href="classaspl_1_1_stream.html#a28cbc9be59540d32a56913e72f9569cd" title="Apply processing to the stream&#39;s data. The provided buffer contains exactly frameCount * channelCount...">Stream::ApplyProcessing()</a> just invokes corresponding methods on attached <a class="el" href="classaspl_1_1_volume_control.html" title="Volume control object.">VolumeControl</a> and <a class="el" href="classaspl_1_1_mute_control.html" title="Mute control object.">MuteControl</a> objects, which you can set using <a class="el" href="classaspl_1_1_stream.html#a15ac54804f85b7a183de4b92960c73e3" title="Attach volume control to the stream. ApplyProcessing() will use control to apply volume settings to t...">AttachVolumeControl()</a> and <a class="el" href="classaspl_1_1_stream.html#aae7db6576eb4ceabc4b248b6638ce2d3" title="Attach mute control to the stream. ApplyProcessing() will use control to apply mute settings to the s...">AttachMuteControl()</a>. </p>

<p class="definition">Definition at line <a class="el" href="_stream_8hpp_source.html#l00076">76</a> of file <a class="el" href="_stream_8hpp_source.html">Stream.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5bc575a321abcd52cd6e69288dd3cb1b" name="a5bc575a321abcd52cd6e69288dd3cb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc575a321abcd52cd6e69288dd3cb1b">&#9670;&#160;</a></span>Stream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">aspl::Stream::Stream </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="structaspl_1_1_context.html">Context</a> &gt;&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classaspl_1_1_device.html">Device</a> &gt;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="structaspl_1_1_stream_parameters.html">StreamParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>params</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct stream. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a28cbc9be59540d32a56913e72f9569cd" name="a28cbc9be59540d32a56913e72f9569cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28cbc9be59540d32a56913e72f9569cd">&#9670;&#160;</a></span>ApplyProcessing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">void</a> aspl::Stream::ApplyProcessing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">Float32</a> *&#160;</td>
          <td class="paramname"><em>frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td>
          <td class="paramname"><em>frameCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td>
          <td class="paramname"><em>channelCount</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply processing to the stream's data. The provided buffer contains exactly <code>frameCount</code> * <code>channelCount</code> samples. Modifies frames in the provided buffer. Default implementation invokes <a class="el" href="classaspl_1_1_stream.html#a28cbc9be59540d32a56913e72f9569cd" title="Apply processing to the stream&#39;s data. The provided buffer contains exactly frameCount * channelCount...">ApplyProcessing()</a> on attached volume and mute controls, if they are present. </p>
<dl class="section note"><dt>Note</dt><dd>Invoked by ReaderWriter on realtime thread. </dd></dl>

</div>
</div>
<a id="aae7db6576eb4ceabc4b248b6638ce2d3" name="aae7db6576eb4ceabc4b248b6638ce2d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7db6576eb4ceabc4b248b6638ce2d3">&#9670;&#160;</a></span>AttachMuteControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">void</a> aspl::Stream::AttachMuteControl </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classaspl_1_1_mute_control.html">MuteControl</a> &gt;&#160;</td>
          <td class="paramname"><em>control</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach mute control to the stream. <a class="el" href="classaspl_1_1_stream.html#a28cbc9be59540d32a56913e72f9569cd" title="Apply processing to the stream&#39;s data. The provided buffer contains exactly frameCount * channelCount...">ApplyProcessing()</a> will use control to apply mute settings to the stream. </p>

</div>
</div>
<a id="a15ac54804f85b7a183de4b92960c73e3" name="a15ac54804f85b7a183de4b92960c73e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ac54804f85b7a183de4b92960c73e3">&#9670;&#160;</a></span>AttachVolumeControl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">void</a> aspl::Stream::AttachVolumeControl </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classaspl_1_1_volume_control.html">VolumeControl</a> &gt;&#160;</td>
          <td class="paramname"><em>control</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach volume control to the stream. <a class="el" href="classaspl_1_1_stream.html#a28cbc9be59540d32a56913e72f9569cd" title="Apply processing to the stream&#39;s data. The provided buffer contains exactly frameCount * channelCount...">ApplyProcessing()</a> will use control to apply volume settings to the stream. </p>

</div>
</div>
<a id="a111814d680ca3cf5762a794a6102a5b7" name="a111814d680ca3cf5762a794a6102a5b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a111814d680ca3cf5762a794a6102a5b7">&#9670;&#160;</a></span>ConvertBytesToFrames()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> aspl::Stream::ConvertBytesToFrames </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td>
          <td class="paramname"><em>numBytes</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert number of bytes to the number of frames. Result depends on the value returned by <a class="el" href="classaspl_1_1_stream.html#a3779d2d4318459c2fd5ff394ca370d18" title="Get the current physical format of the stream. Physical format defines the underlying format supporte...">GetPhysicalFormat()</a>. </p>

</div>
</div>
<a id="aa7ab1436b25290358ca61aff4c708d63" name="aa7ab1436b25290358ca61aff4c708d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7ab1436b25290358ca61aff4c708d63">&#9670;&#160;</a></span>ConvertFramesToBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> aspl::Stream::ConvertFramesToBytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td>
          <td class="paramname"><em>numFrames</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert number of frame to the number of bytes. Result depends on the value returned by <a class="el" href="classaspl_1_1_stream.html#a3779d2d4318459c2fd5ff394ca370d18" title="Get the current physical format of the stream. Physical format defines the underlying format supporte...">GetPhysicalFormat()</a>. </p>

</div>
</div>
<a id="a12ca56e9d287fbe9dbc8ea3ed476acfb" name="a12ca56e9d287fbe9dbc8ea3ed476acfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12ca56e9d287fbe9dbc8ea3ed476acfb">&#9670;&#160;</a></span>GetAvailablePhysicalFormats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamRangedDescription</a> &gt; aspl::Stream::GetAvailablePhysicalFormats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get list of supported physical formats. Empty list means that any format is allowed. By default returns the last value set by <a class="el" href="classaspl_1_1_stream.html#a6ce2c0530917cef98c40824cb696cf0d" title="Asynchronously set list of supported physical formats. See comments for GetAvailablePhysicalFormats()...">SetAvailablePhysicalFormatsAsync()</a>. If nothing was set, return a single-element list with the format returned by <a class="el" href="classaspl_1_1_stream.html#a3779d2d4318459c2fd5ff394ca370d18" title="Get the current physical format of the stream. Physical format defines the underlying format supporte...">GetPhysicalFormat()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyAvailablePhysicalFormats</code> property. </dd></dl>

</div>
</div>
<a id="a088f0e461c9b7ec3cc7adbe94bd8a68f" name="a088f0e461c9b7ec3cc7adbe94bd8a68f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088f0e461c9b7ec3cc7adbe94bd8a68f">&#9670;&#160;</a></span>GetAvailableVirtualFormats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamRangedDescription</a> &gt; aspl::Stream::GetAvailableVirtualFormats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get list of supported virtual formats. Empty list means that any format is allowed. By default returns the last value set by <a class="el" href="classaspl_1_1_stream.html#ad0f8920f04795143ef51fc542847116b" title="Asynchronously set list of supported virtual formats. See comments for GetAvailableVirtualFormats()....">SetAvailableVirtualFormatsAsync()</a>. If nothing was set, return a single-element list with the format returned by <a class="el" href="classaspl_1_1_stream.html#a9306afe1da0566a0ecda0882c25f102d" title="Get the current format of the stream. Virtual format defines the format used to present the device to...">GetVirtualFormat()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyAvailableVirtualFormats</code> property. </dd></dl>

</div>
</div>
<a id="ada9246a40921eceb1469aaa2cadbedc9" name="ada9246a40921eceb1469aaa2cadbedc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada9246a40921eceb1469aaa2cadbedc9">&#9670;&#160;</a></span>GetBaseClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">AudioClassID</a> aspl::Stream::GetBaseClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get base class ID. </p>

<p>Reimplemented from <a class="el" href="classaspl_1_1_object.html#a871df366a43dc1e322002d6714b45720">aspl::Object</a>.</p>

</div>
</div>
<a id="a195b7ca824c7f863931411ec13ab5be0" name="a195b7ca824c7f863931411ec13ab5be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195b7ca824c7f863931411ec13ab5be0">&#9670;&#160;</a></span>GetChannelCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> aspl::Stream::GetChannelCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get number of channels in stream. Return value is based on <a class="el" href="classaspl_1_1_stream.html#a3779d2d4318459c2fd5ff394ca370d18" title="Get the current physical format of the stream. Physical format defines the underlying format supporte...">GetPhysicalFormat()</a>. </p>

</div>
</div>
<a id="ab0247f7359d6632552ad98f841a050b8" name="ab0247f7359d6632552ad98f841a050b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0247f7359d6632552ad98f841a050b8">&#9670;&#160;</a></span>GetClass()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">AudioClassID</a> aspl::Stream::GetClass </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get class ID. </p>

<p>Reimplemented from <a class="el" href="classaspl_1_1_object.html#a68838d5217d7149df9d1de285c7afe4d">aspl::Object</a>.</p>

</div>
</div>
<a id="a363723f08361769c3c1abd4b4bd57cc4" name="a363723f08361769c3c1abd4b4bd57cc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363723f08361769c3c1abd4b4bd57cc4">&#9670;&#160;</a></span>GetDirection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="_direction_8hpp.html#a0e5c4fb0e7a72320da52f055c1c91a41">Direction</a> aspl::Stream::GetDirection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get stream direction. By default returns corresponding field of <a class="el" href="structaspl_1_1_stream_parameters.html" title="Audio stream parameters.">StreamParameters</a>. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="structaspl_1_1_stream_parameters.html#ad15eebf4cbc3cbee4662a4c66917edb8" title="Stream direction. Used by default implementation of Stream::GetDirection().">StreamParameters::Direction</a>. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyDirection</code> property. </dd></dl>

</div>
</div>
<a id="a68583fec1b3439dc38b03c0621adf813" name="a68583fec1b3439dc38b03c0621adf813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68583fec1b3439dc38b03c0621adf813">&#9670;&#160;</a></span>GetIsActive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">bool</a> aspl::Stream::GetIsActive </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tell whether the stream participates in I/O. By default returns the last value set by <a class="el" href="classaspl_1_1_stream.html#a80604ab4a7e215058d396b036f764653" title="Activate or deactivate stream. Invokes SetIsActiveImpl() and NotifyPropertyChanged().">SetIsActive()</a>. Initial value is true. </p>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyIsActive</code> property. </dd></dl>

</div>
</div>
<a id="af59c95b1f8c4681c1351329e0ac89087" name="af59c95b1f8c4681c1351329e0ac89087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af59c95b1f8c4681c1351329e0ac89087">&#9670;&#160;</a></span>GetLatency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> aspl::Stream::GetLatency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get any additonal presentation latency the stream has. This latency is added to the device latency. By default returns value last set with <a class="el" href="classaspl_1_1_stream.html#a00016a0252cac9276ef829379bc73156" title="Asynchronously set stream presentation latency, Requests HAL to asynchronously invoke SetLatencyImpl(...">SetLatencyAsync()</a>. Initial value is <a class="el" href="structaspl_1_1_stream_parameters.html#abe3b514ef7e948df9e6d8c834f10ed63" title="Additonal presentation latency the stream has. Used by default implementation of Stream::GetLatency()...">StreamParameters::Latency</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyLatency</code> property. </dd></dl>

</div>
</div>
<a id="a3779d2d4318459c2fd5ff394ca370d18" name="a3779d2d4318459c2fd5ff394ca370d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3779d2d4318459c2fd5ff394ca370d18">&#9670;&#160;</a></span>GetPhysicalFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamBasicDescription</a> aspl::Stream::GetPhysicalFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current physical format of the stream. Physical format defines the underlying format supported natively by hardware. By default returns value set by last <a class="el" href="classaspl_1_1_stream.html#a94d67ba38b809bce98c61fe750a8af04" title="Set current format of the stream. Requests HAL to asynchronously invoke SetPhysicalFormatImpl()....">SetPhysicalFormatAsync()</a> call. Initial value is <a class="el" href="structaspl_1_1_stream_parameters.html#a97453d492dea4f655d04b609c1ca9be0" title="Stream format. Used by default implementation of Stream::GetPhysicalFormat(). Default format is:">StreamParameters::Format</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyPhysicalFormat</code> property. </dd></dl>

</div>
</div>
<a id="a8a51d941176990e0a4de3188dda6b826" name="a8a51d941176990e0a4de3188dda6b826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a51d941176990e0a4de3188dda6b826">&#9670;&#160;</a></span>GetPropertyData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::GetPropertyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a>&#160;</td>
          <td class="paramname"><em>objectID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">pid_t</a>&#160;</td>
          <td class="paramname"><em>clientPID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td>
          <td class="paramname"><em>qualifierDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">void</a> *&#160;</td>
          <td class="paramname"><em>qualifierData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td>
          <td class="paramname"><em>inDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> *&#160;</td>
          <td class="paramname"><em>outDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">void</a> *&#160;</td>
          <td class="paramname"><em>outData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get property value. </p>

<p>Reimplemented from <a class="el" href="classaspl_1_1_object.html#addc189d05c1d7a02dbde088a6a65b875">aspl::Object</a>.</p>

</div>
</div>
<a id="ac3c3831ad6c98a7b5c8f81a137523e82" name="ac3c3831ad6c98a7b5c8f81a137523e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c3831ad6c98a7b5c8f81a137523e82">&#9670;&#160;</a></span>GetPropertyDataSize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::GetPropertyDataSize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a>&#160;</td>
          <td class="paramname"><em>objectID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">pid_t</a>&#160;</td>
          <td class="paramname"><em>clientPID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td>
          <td class="paramname"><em>qualifierDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">void</a> *&#160;</td>
          <td class="paramname"><em>qualifierData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> *&#160;</td>
          <td class="paramname"><em>outDataSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get size of property value in bytes. </p>

<p>Reimplemented from <a class="el" href="classaspl_1_1_object.html#a139184c6e40b446950fc9e4fb2d44308">aspl::Object</a>.</p>

</div>
</div>
<a id="ad7d1bdf278120bbf0114545f9511c844" name="ad7d1bdf278120bbf0114545f9511c844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d1bdf278120bbf0114545f9511c844">&#9670;&#160;</a></span>GetSampleRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">Float64</a> aspl::Stream::GetSampleRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get stream sample rate. Return value is based on <a class="el" href="classaspl_1_1_stream.html#a3779d2d4318459c2fd5ff394ca370d18" title="Get the current physical format of the stream. Physical format defines the underlying format supporte...">GetPhysicalFormat()</a>. </p>

</div>
</div>
<a id="a269d731977c0761592a40f83818a951c" name="a269d731977c0761592a40f83818a951c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a269d731977c0761592a40f83818a951c">&#9670;&#160;</a></span>GetStartingChannel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> aspl::Stream::GetStartingChannel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Absolute channel number for the first channel in the stream. For exmaple, if a device has two output streams with two channels each, then the starting channel number for the first stream is 1 and thus starting channel number for the second stream is 3. By default returns <a class="el" href="structaspl_1_1_stream_parameters.html#a69a2537e7e808c88cda8ae97ab42096a" title="Absolute channel number for the first channel in the stream. Used by default implementation of Stream...">StreamParameters::StartingChannel</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyStartingChannel</code> property. </dd></dl>

</div>
</div>
<a id="ad832d9656718cf294718f78865e2cc26" name="ad832d9656718cf294718f78865e2cc26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad832d9656718cf294718f78865e2cc26">&#9670;&#160;</a></span>GetTerminalType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a> aspl::Stream::GetTerminalType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get terminal type. By default returns kAudioStreamTerminalTypeMicrophone if <a class="el" href="classaspl_1_1_stream.html#a363723f08361769c3c1abd4b4bd57cc4" title="Get stream direction. By default returns corresponding field of StreamParameters.">GetDirection()</a> returns <a class="el" href="_direction_8hpp.html#a0e5c4fb0e7a72320da52f055c1c91a41a324118a6721dd6b8a9b9f4e327df2bf5" title="Input direction.">Direction::Input</a>, and kAudioStreamTerminalTypeSpeaker if it return <a class="el" href="_direction_8hpp.html#a0e5c4fb0e7a72320da52f055c1c91a41a29c2c02a361c9d7028472e5d92cd4a54" title="Output direction.">Direction::Output</a>. </p>
<dl class="section remark"><dt>Remarks</dt><dd>Indicates what is at the other end of the stream such as a speaker or headphones, or a microphone. Values for this property are defined in &lt;CoreAudio/AudioHardwareBase.h&gt; </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyTerminalType</code> property. </dd></dl>

</div>
</div>
<a id="a9306afe1da0566a0ecda0882c25f102d" name="a9306afe1da0566a0ecda0882c25f102d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9306afe1da0566a0ecda0882c25f102d">&#9670;&#160;</a></span>GetVirtualFormat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamBasicDescription</a> aspl::Stream::GetVirtualFormat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current format of the stream. Virtual format defines the format used to present the device to the apps. For example, physical format may use integers, while virtual format may use floating point numbers. For devices that don't override the mix operation, the virtual format has to be the same as the physical format. By default returns value set by last <a class="el" href="classaspl_1_1_stream.html#aa407cbaf8ebc7fec652b09153616b795" title="Set current virtual format of the stream. Requests HAL to asynchronously invoke SetVirtualFormatImpl(...">SetVirtualFormatAsync()</a> call. Initial value is <a class="el" href="structaspl_1_1_stream_parameters.html#a97453d492dea4f655d04b609c1ca9be0" title="Stream format. Used by default implementation of Stream::GetPhysicalFormat(). Default format is:">StreamParameters::Format</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyVirtualFormat</code> property. </dd></dl>

</div>
</div>
<a id="a7d9af7fb00e85380539243bb11ba73be" name="a7d9af7fb00e85380539243bb11ba73be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9af7fb00e85380539243bb11ba73be">&#9670;&#160;</a></span>HasProperty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">Boolean</a> aspl::Stream::HasProperty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a>&#160;</td>
          <td class="paramname"><em>objectID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">pid_t</a>&#160;</td>
          <td class="paramname"><em>clientPID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether given property is present. </p>

<p>Reimplemented from <a class="el" href="classaspl_1_1_object.html#a4ee44270556d0fd40056f45f7061f244">aspl::Object</a>.</p>

</div>
</div>
<a id="ad4da7a1929c7b397754c05b673e85769" name="ad4da7a1929c7b397754c05b673e85769"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4da7a1929c7b397754c05b673e85769">&#9670;&#160;</a></span>IsInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">bool</a> aspl::Stream::IsInstance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">AudioClassID</a>&#160;</td>
          <td class="paramname"><em>classID</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check if this object is instance of given base class. </p>

<p>Reimplemented from <a class="el" href="classaspl_1_1_object.html#a67ff23c417a5ed0a860ff84e1ef62181">aspl::Object</a>.</p>

</div>
</div>
<a id="a0cef45207c5c0b071644c8274d66ff39" name="a0cef45207c5c0b071644c8274d66ff39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cef45207c5c0b071644c8274d66ff39">&#9670;&#160;</a></span>IsPropertySettable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::IsPropertySettable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a>&#160;</td>
          <td class="paramname"><em>objectID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">pid_t</a>&#160;</td>
          <td class="paramname"><em>clientPID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">Boolean</a> *&#160;</td>
          <td class="paramname"><em>outIsSettable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check whether given property can be changed. </p>

<p>Reimplemented from <a class="el" href="classaspl_1_1_object.html#ac45d41b7b7f5295c58ba3bde15f23972">aspl::Object</a>.</p>

</div>
</div>
<a id="af7ffc3cb8d8e121db0ca98c2c60b621b" name="af7ffc3cb8d8e121db0ca98c2c60b621b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ffc3cb8d8e121db0ca98c2c60b621b">&#9670;&#160;</a></span>RequestConfigurationChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">void</a> aspl::Stream::RequestConfigurationChange </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; <a class="el" href="classaspl_1_1_double_buffer.html">void</a>()&gt;&#160;</td>
          <td class="paramname"><em>func</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Request HAL to perform configuration update. Similar to <a class="el" href="classaspl_1_1_device.html#a9a5aeeacc257fbc5974de7d7c7177589" title="Request HAL to perform configuration update.">Device::RequestConfigurationChange()</a>. </p>

</div>
</div>
<a id="a6ce2c0530917cef98c40824cb696cf0d" name="a6ce2c0530917cef98c40824cb696cf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce2c0530917cef98c40824cb696cf0d">&#9670;&#160;</a></span>SetAvailablePhysicalFormatsAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::SetAvailablePhysicalFormatsAsync </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamRangedDescription</a> &gt;&#160;</td>
          <td class="paramname"><em>formats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously set list of supported physical formats. See comments for <a class="el" href="classaspl_1_1_stream.html#a12ca56e9d287fbe9dbc8ea3ed476acfb" title="Get list of supported physical formats. Empty list means that any format is allowed....">GetAvailablePhysicalFormats()</a>. Requests HAL to asynchronously invoke <a class="el" href="classaspl_1_1_stream.html#a945fa39c9b9e6e5f8418f9283f53dcb2" title="Set list of supported physical formats. Invoked by SetAvailablePhysicalFormatsAsync()....">SetAvailablePhysicalFormatsImpl()</a>. </p>

</div>
</div>
<a id="a945fa39c9b9e6e5f8418f9283f53dcb2" name="a945fa39c9b9e6e5f8418f9283f53dcb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945fa39c9b9e6e5f8418f9283f53dcb2">&#9670;&#160;</a></span>SetAvailablePhysicalFormatsImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::SetAvailablePhysicalFormatsImpl </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamRangedDescription</a> &gt;&#160;</td>
          <td class="paramname"><em>formats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set list of supported physical formats. Invoked by <a class="el" href="classaspl_1_1_stream.html#a6ce2c0530917cef98c40824cb696cf0d" title="Asynchronously set list of supported physical formats. See comments for GetAvailablePhysicalFormats()...">SetAvailablePhysicalFormatsAsync()</a>. Default implementation just changes the list returned by <a class="el" href="classaspl_1_1_stream.html#a12ca56e9d287fbe9dbc8ea3ed476acfb" title="Get list of supported physical formats. Empty list means that any format is allowed....">GetAvailablePhysicalFormats()</a>. </p>

</div>
</div>
<a id="ad0f8920f04795143ef51fc542847116b" name="ad0f8920f04795143ef51fc542847116b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f8920f04795143ef51fc542847116b">&#9670;&#160;</a></span>SetAvailableVirtualFormatsAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::SetAvailableVirtualFormatsAsync </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamRangedDescription</a> &gt;&#160;</td>
          <td class="paramname"><em>formats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously set list of supported virtual formats. See comments for <a class="el" href="classaspl_1_1_stream.html#a088f0e461c9b7ec3cc7adbe94bd8a68f" title="Get list of supported virtual formats. Empty list means that any format is allowed....">GetAvailableVirtualFormats()</a>. Requests HAL to asynchronously invoke <a class="el" href="classaspl_1_1_stream.html#af5526abdc03ab8f87ae812db3cd853e9" title="Set list of supported virtual formats. Invoked by SetAvailableVirtualFormatsAsync()....">SetAvailableVirtualFormatsImpl()</a>. </p>

</div>
</div>
<a id="af5526abdc03ab8f87ae812db3cd853e9" name="af5526abdc03ab8f87ae812db3cd853e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5526abdc03ab8f87ae812db3cd853e9">&#9670;&#160;</a></span>SetAvailableVirtualFormatsImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::SetAvailableVirtualFormatsImpl </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamRangedDescription</a> &gt;&#160;</td>
          <td class="paramname"><em>formats</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set list of supported virtual formats. Invoked by <a class="el" href="classaspl_1_1_stream.html#ad0f8920f04795143ef51fc542847116b" title="Asynchronously set list of supported virtual formats. See comments for GetAvailableVirtualFormats()....">SetAvailableVirtualFormatsAsync()</a>. Default implementation just changes the list returned by <a class="el" href="classaspl_1_1_stream.html#a088f0e461c9b7ec3cc7adbe94bd8a68f" title="Get list of supported virtual formats. Empty list means that any format is allowed....">GetAvailableVirtualFormats()</a>. </p>

</div>
</div>
<a id="a80604ab4a7e215058d396b036f764653" name="a80604ab4a7e215058d396b036f764653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80604ab4a7e215058d396b036f764653">&#9670;&#160;</a></span>SetIsActive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::SetIsActive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">bool</a>&#160;</td>
          <td class="paramname"><em>isActive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Activate or deactivate stream. Invokes <a class="el" href="classaspl_1_1_stream.html#a216cad2cde7c521f16429c7caf26421e" title="Activate or deactivate stream. Should return zero if the state was successfully changed....">SetIsActiveImpl()</a> and <a class="el" href="classaspl_1_1_object.html#a53f2d1bb9cd6d4d67e7d5a12208f7e23" title="Notify HAL that a property was changed. This is automatically called by all setters.">NotifyPropertyChanged()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyIsActive</code> property. </dd></dl>

</div>
</div>
<a id="a216cad2cde7c521f16429c7caf26421e" name="a216cad2cde7c521f16429c7caf26421e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a216cad2cde7c521f16429c7caf26421e">&#9670;&#160;</a></span>SetIsActiveImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::SetIsActiveImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">bool</a>&#160;</td>
          <td class="paramname"><em>isActive</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activate or deactivate stream. Should return zero if the state was successfully changed. By default just changes the value returned by <a class="el" href="classaspl_1_1_stream.html#a68583fec1b3439dc38b03c0621adf813" title="Tell whether the stream participates in I/O. By default returns the last value set by SetIsActive()....">GetIsActive()</a>. Invoked by <a class="el" href="classaspl_1_1_stream.html#a80604ab4a7e215058d396b036f764653" title="Activate or deactivate stream. Invokes SetIsActiveImpl() and NotifyPropertyChanged().">SetIsActive()</a>. </p>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyIsActive</code> property. </dd></dl>

</div>
</div>
<a id="a00016a0252cac9276ef829379bc73156" name="a00016a0252cac9276ef829379bc73156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00016a0252cac9276ef829379bc73156">&#9670;&#160;</a></span>SetLatencyAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::SetLatencyAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td>
          <td class="paramname"><em>latency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Asynchronously set stream presentation latency, Requests HAL to asynchronously invoke <a class="el" href="classaspl_1_1_stream.html#a3b449340ad949b2753a3c47a0d9fa4b4" title="Set stream presentation latency. Invoked by SetLatencyAsync() to actually change the latency....">SetLatencyImpl()</a>. </p>

</div>
</div>
<a id="a3b449340ad949b2753a3c47a0d9fa4b4" name="a3b449340ad949b2753a3c47a0d9fa4b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b449340ad949b2753a3c47a0d9fa4b4">&#9670;&#160;</a></span>SetLatencyImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::SetLatencyImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td>
          <td class="paramname"><em>latency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set stream presentation latency. Invoked by <a class="el" href="classaspl_1_1_stream.html#a00016a0252cac9276ef829379bc73156" title="Asynchronously set stream presentation latency, Requests HAL to asynchronously invoke SetLatencyImpl(...">SetLatencyAsync()</a> to actually change the latency. Default implementation just changes the value returned by <a class="el" href="classaspl_1_1_stream.html#af59c95b1f8c4681c1351329e0ac89087" title="Get any additonal presentation latency the stream has. This latency is added to the device latency....">GetLatency()</a>. </p>

</div>
</div>
<a id="a94d67ba38b809bce98c61fe750a8af04" name="a94d67ba38b809bce98c61fe750a8af04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d67ba38b809bce98c61fe750a8af04">&#9670;&#160;</a></span>SetPhysicalFormatAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::SetPhysicalFormatAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamBasicDescription</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set current format of the stream. Requests HAL to asynchronously invoke <a class="el" href="classaspl_1_1_stream.html#a1fbb344a968da9cca8031586ef4c8423" title="Set current format of the stream. Invoked by SetPhysicalFormatAsync() to actually change the format....">SetPhysicalFormatImpl()</a>. Fails if format is not present in <a class="el" href="classaspl_1_1_stream.html#a12ca56e9d287fbe9dbc8ea3ed476acfb" title="Get list of supported physical formats. Empty list means that any format is allowed....">GetAvailablePhysicalFormats()</a>, which by default returns only one format, provided during initialization. If you want to make your stream supporting multiple formats, you typically need to override both of these methods. </p>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyPhysicalFormat</code> property. </dd></dl>

</div>
</div>
<a id="a1fbb344a968da9cca8031586ef4c8423" name="a1fbb344a968da9cca8031586ef4c8423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbb344a968da9cca8031586ef4c8423">&#9670;&#160;</a></span>SetPhysicalFormatImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::SetPhysicalFormatImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamBasicDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set current format of the stream. Invoked by <a class="el" href="classaspl_1_1_stream.html#a94d67ba38b809bce98c61fe750a8af04" title="Set current format of the stream. Requests HAL to asynchronously invoke SetPhysicalFormatImpl()....">SetPhysicalFormatAsync()</a> to actually change the format. Default behavior is to change the format returned by <a class="el" href="classaspl_1_1_stream.html#a3779d2d4318459c2fd5ff394ca370d18" title="Get the current physical format of the stream. Physical format defines the underlying format supporte...">GetPhysicalFormat()</a> and to invoke Device::SetSampleRateAsync() to ensure that device and all its streams have the same rate. </p>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyPhysicalFormat</code> property. </dd></dl>

</div>
</div>
<a id="a5640cd0c7dcc99c9a2956527591f4d2b" name="a5640cd0c7dcc99c9a2956527591f4d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5640cd0c7dcc99c9a2956527591f4d2b">&#9670;&#160;</a></span>SetPropertyData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::SetPropertyData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectID</a>&#160;</td>
          <td class="paramname"><em>objectID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">pid_t</a>&#160;</td>
          <td class="paramname"><em>clientPID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioObjectPropertyAddress</a> *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td>
          <td class="paramname"><em>qualifierDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">void</a> *&#160;</td>
          <td class="paramname"><em>qualifierData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">UInt32</a>&#160;</td>
          <td class="paramname"><em>inDataSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">void</a> *&#160;</td>
          <td class="paramname"><em>inData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Change property value. </p>

<p>Reimplemented from <a class="el" href="classaspl_1_1_object.html#ae8839747b0b5a50bdd7cb18392354deb">aspl::Object</a>.</p>

</div>
</div>
<a id="aa407cbaf8ebc7fec652b09153616b795" name="aa407cbaf8ebc7fec652b09153616b795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa407cbaf8ebc7fec652b09153616b795">&#9670;&#160;</a></span>SetVirtualFormatAsync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::SetVirtualFormatAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamBasicDescription</a>&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set current virtual format of the stream. Requests HAL to asynchronously invoke <a class="el" href="classaspl_1_1_stream.html#af874a8b508b980c9d6d9e044507eb17d" title="Set current virtual format of the stream. Invoked by SetVirtualFormatAsync() to actually change the f...">SetVirtualFormatImpl()</a>. Fails if format is not present in <a class="el" href="classaspl_1_1_stream.html#a088f0e461c9b7ec3cc7adbe94bd8a68f" title="Get list of supported virtual formats. Empty list means that any format is allowed....">GetAvailableVirtualFormats()</a>, which by default returns only one format, provided during initialization. If you want to make your stream supporting multiple formats, you typically need to override both of these methods. </p>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyVirtualFormat</code> property. </dd></dl>

</div>
</div>
<a id="af874a8b508b980c9d6d9e044507eb17d" name="af874a8b508b980c9d6d9e044507eb17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af874a8b508b980c9d6d9e044507eb17d">&#9670;&#160;</a></span>SetVirtualFormatImpl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classaspl_1_1_double_buffer.html">virtual</a> <a class="el" href="classaspl_1_1_double_buffer.html">OSStatus</a> aspl::Stream::SetVirtualFormatImpl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classaspl_1_1_double_buffer.html">const</a> <a class="el" href="classaspl_1_1_double_buffer.html">AudioStreamBasicDescription</a> &amp;&#160;</td>
          <td class="paramname"><em>format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set current virtual format of the stream. Invoked by <a class="el" href="classaspl_1_1_stream.html#aa407cbaf8ebc7fec652b09153616b795" title="Set current virtual format of the stream. Requests HAL to asynchronously invoke SetVirtualFormatImpl(...">SetVirtualFormatAsync()</a> to actually change the format. Default behavior is to change the format returned by <a class="el" href="classaspl_1_1_stream.html#a9306afe1da0566a0ecda0882c25f102d" title="Get the current format of the stream. Virtual format defines the format used to present the device to...">GetVirtualFormat()</a> and to invoke Device::SetSampleRateAsync() to ensure that device and all its streams have the same rate. </p>
<dl class="section note"><dt>Note</dt><dd>Backs <code>kAudioStreamPropertyVirtualFormat</code> property. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>aspl/<a class="el" href="_stream_8hpp_source.html">Stream.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>aspl</b></li><li class="navelem"><a class="el" href="classaspl_1_1_stream.html">Stream</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
